import{_ as a,c as t,a0 as s,o as i}from"./chunks/framework.ToOB-GtV.js";const d=JSON.parse('{"title":"2.基于JetCache多级缓存实现用户信息快速查询","description":"","frontmatter":{},"headers":[],"relativePath":"practice/cache.md","filePath":"practice/cache.md"}'),n={name:"practice/cache.md"};function p(l,e,c,r,u,o){return i(),t("div",null,e[0]||(e[0]=[s(`<h1 id="_2-基于jetcache多级缓存实现用户信息快速查询" tabindex="-1">2.基于JetCache多级缓存实现用户信息快速查询 <a class="header-anchor" href="#_2-基于jetcache多级缓存实现用户信息快速查询" aria-label="Permalink to &quot;2.基于JetCache多级缓存实现用户信息快速查询&quot;">​</a></h1><p>在我们的项目中，经常会需要查询用户信息，比如前端页面需要展示，用户下单需要查询，交易成功后上链时也需要查询。</p><p>而这些用户信息，很多内容都是不变的，比如用户的昵称、手机号，或者说是变化不频发的。所以这些数据我们就可以做缓存。</p><p>在缓存选择上，我们不仅用了分布式缓存，同时为了提升性能，还做了本地缓存。也就是说我们的一次查询，会先查询本地缓存，如果本地缓存查不到，再查询分布式缓存。并且在分布式缓存中查询到之后保存到本地缓存中一份。</p><p>在传统代码中，我们需要在代码中多次判断是否存在，很不方便</p><p>但是为了方便，减少这段代码，我们选择用通用的二级缓存框架，阿里开源的 JetCache。</p><p>JetCache是一个基于java的缓存系统封装，提供统一的API和注解简化缓存的使用。 JetCache提供了比SpringCache更强大的注解，可以原生的支持TTL、两级缓存、分布式自动刷新，提供了Cache接口用于手工缓存操作。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@GetMapping(&quot;/articleStrategy&quot;)</span></span>
<span class="line"><span>    @Operation(summary = &quot;分页查询 获取所有游记&quot;)</span></span>
<span class="line"><span>    @Cached(name = &quot;StrategyList-&quot;, key = &quot;#pageNum + &#39;-&#39; + #pageSize&quot;, expire = 3600) // 设置缓存</span></span>
<span class="line"><span>    public Result&lt;List&lt;ArticleResponse&gt;&gt; listArticleStrategy(@RequestParam(defaultValue = &quot;1&quot;) Integer pageNum,</span></span>
<span class="line"><span>                                                                                                  @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) {</span></span>
<span class="line"><span>        return articleService.listArticleStrategy(pageNum, pageSize);</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@Cached(name = &quot;:user:cache:id:&quot;, expire = 3000, cacheType = CacheType.REMOTE, key = &quot;#userId&quot;, cacheNullValue = true)</span></span>
<span class="line"><span>@CacheRefresh(refresh = 60, timeUnit = TimeUnit.MINUTES)</span></span>
<span class="line"><span>@CacheInvalidate(name = &quot;:user:cache:id:&quot;, key = &quot;#userModifyRequest.userId&quot;)</span></span></code></pre></div><ul><li>@Cached：为一个方法添加缓存，创建对应的缓存实例，注解可以添加在接口或者类的方法上面，该类必须是spring bean</li><li>name：指定缓存实例名称，如果没有指定，会根据类名+方法名自动生成。</li><li>expire：超时时间。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为无穷大。</li><li>cacheType：缓存的类型，支持：REMOTE、LOCAL、BOTH，如果定义为BOTH，会使用LOCAL和REMOTE组合成两级缓存。</li><li>key：使用SpEL指定缓存key，如果没有指定会根据入参自动生成。</li><li>cacheNullValue：当方法返回值为null的时候是否要缓存。</li><li>@CacheRefresh：用于标识这个缓存需要自动刷新</li><li>refresh：刷新的时间间隔</li><li>timeUnit：时间单位</li><li>CacheInvalidate：用于标识这个方法被调用时需要移除缓存</li><li>name：指定缓存的唯一名称，一般指向对应的@Cached定义的name。</li><li>key：使用SpEL指定key，如果没有指定会根据入参自动生成。</li></ul>`,10)]))}const g=a(n,[["render",p]]);export{d as __pageData,g as default};
